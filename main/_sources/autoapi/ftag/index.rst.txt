ftag
====

.. py:module:: ftag

.. autoapi-nested-parse::

   atlas-ftag-tools - Common tools for ATLAS flavour tagging software.



Submodules
----------

.. toctree::
   :maxdepth: 1

   /autoapi/ftag/cli_utils/index
   /autoapi/ftag/cuts/index
   /autoapi/ftag/find_metadata/index
   /autoapi/ftag/fraction_optimization/index
   /autoapi/ftag/git_check/index
   /autoapi/ftag/hdf5/index
   /autoapi/ftag/mock/index
   /autoapi/ftag/sample/index
   /autoapi/ftag/transform/index
   /autoapi/ftag/utils/index
   /autoapi/ftag/vds/index
   /autoapi/ftag/working_points/index


Attributes
----------

.. autoapisummary::

   ftag.__version__


Exceptions
----------

.. autoapisummary::

   ftag.GitError


Classes
-------

.. autoapisummary::

   ftag.Cuts
   ftag.Sample
   ftag.Transform


Functions
---------

.. autoapisummary::

   ftag.calculate_best_fraction_values
   ftag.check_for_fork
   ftag.check_for_uncommitted_changes
   ftag.create_and_push_tag
   ftag.get_git_hash
   ftag.is_git_repo
   ftag.get_mock_file


Package Contents
----------------

.. py:data:: __version__
   :value: 'v0.2.18'


.. py:class:: Cuts

   Cuts dataclass to store multiple Cut instances and apply them.

   .. attribute:: cuts

      Tuple with the Cut instances

      :type: tuple[Cut, ...]


   .. py:attribute:: cuts
      :type:  tuple[Cut, Ellipsis]


   .. py:method:: from_list(cuts: list) -> Cuts
      :classmethod:



   .. py:method:: empty() -> Cuts
      :classmethod:



   .. py:method:: __post_init__()


   .. py:property:: variables
      :type: list[str]



   .. py:method:: ignore(variables: list[str])


   .. py:method:: __call__(array: numpy.ndarray) -> CutsResult


   .. py:method:: __add__(other: Cuts)


   .. py:method:: __len__() -> int


   .. py:method:: __iter__() -> collections.abc.Iterator


   .. py:method:: __getitem__(variable)


   .. py:method:: __repr__() -> str


.. py:function:: calculate_best_fraction_values(jets: numpy.ndarray, tagger: str, signal: ftag.labels.Label, flavours: ftag.labels.LabelContainer, working_point: float, rejection_weights: dict | None = None, optimizer_method: str = 'Powell') -> dict

   Calculate the best fraction values for a given tagger and working point.

   :param jets: Loaded jets
   :type jets: np.ndarray
   :param tagger: Name of the tagger
   :type tagger: str
   :param signal: Label instance of the signal
   :type signal: Label
   :param flavours: LabelContainer with all flavours
   :type flavours: LabelContainer
   :param working_point: Working point that is used
   :type working_point: float
   :param rejection_weights: Rejection weights for the background classes, by default None
   :type rejection_weights: dict | None, optional
   :param optimizer_method: Optimizer method for the minimization, by default "Powell"
   :type optimizer_method: str, optional

   :returns: Dict with the best fraction values
   :rtype: dict


.. py:exception:: GitError

   Bases: :py:obj:`Exception`


   Raised when a Git-related precondition is not satisfied.

   Initialize self.  See help(type(self)) for accurate signature.


.. py:function:: check_for_fork(path: str | os.PathLike[str], upstream: str) -> None

   Ensure the local clone's ``origin`` remote is a fork of ``upstream``.

   :param path: Filesystem path to the repository root or any directory within it.
   :type path: str | PathLike[str]
   :param upstream: Expected upstream repository URL substring (e.g. ``'github.com/org/repo'``).
   :type upstream: str

   :raises GitError: If the repository is present but its ``origin`` URL does not contain ``upstream``.

   .. rubric:: Notes

   If ``path`` is not a Git repository, the function returns silently.


.. py:function:: check_for_uncommitted_changes(path: str | os.PathLike[str]) -> None

   Raise if the repository at ``path`` has uncommitted changes.

   :param path: Filesystem path to the repository root or any directory within it.
   :type path: str | PathLike[str]

   :raises GitError: If ``path`` is a Git repository and there are uncommitted changes.

   .. rubric:: Notes

   - If ``path`` is **not** a Git repository, the function returns silently.
   - If the current process is running under ``pytest`` (detected via
     :data:`sys.modules`), the check is skipped and the function returns.


.. py:function:: create_and_push_tag(path: str | os.PathLike[str], upstream: str, tagname: str, msg: str) -> None

   Create an annotated Git tag and push it to ``origin``.

   :param path: Filesystem path to the repository root or any directory within it.
   :type path: str | PathLike[str]
   :param upstream: Expected upstream repository URL substring; passed to :func:`check_for_fork`.
   :type upstream: str
   :param tagname: Name of the tag to create.
   :type tagname: str
   :param msg: Annotation message for the tag (``git tag -m``).
   :type msg: str

   .. rubric:: Notes

   If ``path`` is not a Git repository, the function returns silently.


.. py:function:: get_git_hash(path: str | os.PathLike[str]) -> str | None

   Return the short commit hash for ``HEAD`` at ``path``, if available.

   :param path: Filesystem path to the repository root or any directory within it.
   :type path: str | PathLike[str]

   :returns: The short (``--short``) commit hash as a string, or ``None`` if ``path`` is
             not a Git repository.
   :rtype: str | None


.. py:function:: is_git_repo(path: str | os.PathLike[str]) -> bool

   Return whether ``path`` is inside a Git working tree.

   :param path: Filesystem path used as the current working directory for the Git command.
   :type path: str | PathLike[str]

   :returns: ``True`` if ``path`` is inside a Git working tree, ``False`` otherwise.
   :rtype: bool

   .. rubric:: Notes

   This function runs::

       git rev-parse --is-inside-work-tree HEAD

   Any non-zero exit status is treated as "not a Git repository". If Git is not
   available on the system, an :class:`OSError` may be raised by :mod:`subprocess`.


.. py:function:: get_mock_file(num_jets: int = 1000, fname: str | None = None, tracks_name: str = 'tracks', num_tracks: int = 40) -> tuple[str, h5py.File]

   Get a mock file for testing.

   :param num_jets: Number of jets in the file, by default 1000
   :type num_jets: int, optional
   :param fname: Name of the file, by default None
   :type fname: str | None, optional
   :param tracks_name: Name of the tracks dataset, by default "tracks"
   :type tracks_name: str, optional
   :param num_tracks: Number of tracks per jet, by default 40
   :type num_tracks: int, optional

   :returns: Tuple with the path and the h5 file
   :rtype: tuple[str, h5py.File]


.. py:class:: Sample

   Dataclass which holds info about a specific sample.

   .. attribute:: pattern

      Filepattern for the h5 files

      :type: Path | str | tuple[Path | str, ...]

   .. attribute:: ntuple_dir

      Ntuple directory where the h5 files are stored, by default None

      :type: Path | str | None, optional

   .. attribute:: name

      Name of the sample, for internal identification, by default None

      :type: str | None, optional

   .. attribute:: weights

      List of weights for this sample, by default None

      :type: list[float] | None, optional

   .. attribute:: skip_checks

      Decide, if certain checks are skipped, by default False

      :type: bool, optional

   .. attribute:: vds_dir

      Directory where virtual datasets will be stored if wildcard is used, by default None.
      If None, the virtual files will be created in the same directory as the input files.

      :type: Path | str | None, optional


   .. py:attribute:: pattern
      :type:  pathlib.Path | str | tuple[pathlib.Path | str, Ellipsis]


   .. py:attribute:: ntuple_dir
      :type:  pathlib.Path | str | None
      :value: None



   .. py:attribute:: name
      :type:  str | None
      :value: None



   .. py:attribute:: weights
      :type:  list[float] | None
      :value: None



   .. py:attribute:: skip_checks
      :type:  bool
      :value: False



   .. py:attribute:: vds_dir
      :type:  pathlib.Path | str | None
      :value: None



   .. py:method:: __post_init__() -> None


   .. py:property:: path
      :type: tuple[pathlib.Path, Ellipsis]



   .. py:property:: files
      :type: list[str]



   .. py:property:: num_files
      :type: int



   .. py:property:: dsid
      :type: list[str]



   .. py:property:: sample_id
      :type: list[str]



   .. py:property:: tags
      :type: list[str]



   .. py:property:: ptag
      :type: list[str]



   .. py:property:: rtag
      :type: list[str]



   .. py:property:: dumper_tag
      :type: list[str]



   .. py:method:: virtual_file(**kwargs) -> list[pathlib.Path | str]


   .. py:method:: __str__()


   .. py:method:: __lt__(other)


   .. py:method:: __eq__(other)


.. py:class:: Transform

   Apply variable name remapping, integer remapping, and float transformations.

   The Transform class provides a unified mechanism to perform:
   - variable renaming (variable_map)
   - integer value remapping (ints_map)
   - float transformations (floats_map)

   Each transformation is applied to a *batch* consisting of a dictionary of
   structured numpy arrays.

   .. attribute:: variable_map

      A nested mapping where variable_map[group][old] = new specifies how
      variable names should be renamed inside a given group. If None, no
      variable renaming is applied.

      :type: dict[str, dict[str, str]]

   .. attribute:: ints_map

      A nested mapping where ints_map[group][variable][old] = new specifies
      how integer values should be remapped. If None, no integer remapping
      is applied.

      :type: dict[str, dict[str, dict[int, int]]]

   .. attribute:: floats_map

      A nested mapping where floats_map[group][variable] = func specifies
      a float transformation function. func may either be:
      - a callable
      - a string giving the name of a numpy function (e.g. "log")

      Strings are resolved to numpy.<func> automatically.

      :type: dict[str, dict[str, str | Callable]]

   .. attribute:: variable_map_inv

      Automatically generated inverse of variable_map used for reverse
      variable lookup in :meth:`map_variable_names`.

      :type: dict[str, dict[str, str]]


   .. py:attribute:: variable_map
      :type:  dict[str, dict[str, str]]


   .. py:attribute:: ints_map
      :type:  dict[str, dict[str, dict[int, int]]]


   .. py:attribute:: floats_map
      :type:  dict[str, dict[str, str | collections.abc.Callable]]


   .. py:attribute:: variable_map_inv
      :type:  dict[str, dict[str, str]]


   .. py:method:: __post_init__() -> None

      Initialize internal maps and convert float transformation strings.

      This method ensures that variable_map, ints_map, and
      floats_map are always dictionaries (never None), constructs the
      inverse variable map, and converts any string-based float
      transformations into their numpy equivalents.



   .. py:method:: __call__(batch: Batch) -> Batch

      Apply integer remapping, float transformations, and variable renaming.

      :param batch: A mapping from group name to structured numpy arrays.
      :type batch: Batch

      :returns: The transformed batch.
      :rtype: Batch



   .. py:method:: map_variables(batch: Batch) -> Batch

      Rename variables in each group according to variable_map.

      :param batch: Dictionary mapping group names to structured numpy arrays.
      :type batch: Batch

      :returns: The batch with variables renamed where applicable.
      :rtype: Batch



   .. py:method:: map_ints(batch: Batch) -> Batch

      Remap integer values for specified variables inside each group.

      :param batch: Dictionary mapping group names to structured numpy arrays.
      :type batch: Batch

      :returns: The batch with integer values remapped.
      :rtype: Batch



   .. py:method:: map_floats(batch: Batch) -> Batch

      Apply float transformations to selected variables.

      :param batch: Dictionary mapping group names to structured numpy arrays.
      :type batch: Batch

      :returns: The batch with float transformations applied.
      :rtype: Batch



   .. py:method:: map_dtype(name: str, dtype: numpy.dtype) -> numpy.dtype

      Compute a new dtype with renamed fields according to variable_map.

      :param name: Group name associated with the dtype.
      :type name: str
      :param dtype: Structured dtype whose field names may be modified.
      :type dtype: np.dtype

      :returns: A dtype with renamed fields where required.
      :rtype: np.dtype

      :raises ValueError: When the variables already exist in the dataset.



   .. py:method:: map_variable_names(name: str, variables: list[str], inverse: bool = False) -> list[str]

      Map a list of variable names using variable_map or variable_map_inv.

      :param name: Group name used to select the appropriate name-mapping dictionary.
      :type name: str
      :param variables: List of variable names to be mapped.
      :type variables: list[str]
      :param inverse: If False (default), apply variable_map.
                      If True, apply the inverse mapping variable_map_inv.
      :type inverse: bool, optional

      :returns: A new list of mapped variable names.
      :rtype: list[str]



