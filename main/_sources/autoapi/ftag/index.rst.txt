ftag
====

.. py:module:: ftag

.. autoapi-nested-parse::

   atlas-ftag-tools - Common tools for ATLAS flavour tagging software.



Submodules
----------

.. toctree::
   :maxdepth: 1

   /autoapi/ftag/cli_utils/index
   /autoapi/ftag/cuts/index
   /autoapi/ftag/flavours/index
   /autoapi/ftag/fraction_optimization/index
   /autoapi/ftag/git_check/index
   /autoapi/ftag/hdf5/index
   /autoapi/ftag/labels/index
   /autoapi/ftag/mock/index
   /autoapi/ftag/region/index
   /autoapi/ftag/sample/index
   /autoapi/ftag/track_selector/index
   /autoapi/ftag/transform/index
   /autoapi/ftag/utils/index
   /autoapi/ftag/vds/index
   /autoapi/ftag/working_points/index


Attributes
----------

.. autoapisummary::

   ftag.__version__
   ftag.Flavours


Classes
-------

.. autoapisummary::

   ftag.Cuts
   ftag.Label
   ftag.LabelContainer
   ftag.Sample
   ftag.Transform


Functions
---------

.. autoapisummary::

   ftag.get_mock_file
   ftag.get_working_points


Package Contents
----------------

.. py:data:: __version__
   :value: 'v0.2.14'


.. py:class:: Cuts

   .. py:attribute:: cuts
      :type:  tuple[Cut, Ellipsis]


   .. py:method:: from_list(cuts: list) -> Cuts
      :classmethod:



   .. py:method:: empty() -> Cuts
      :classmethod:



   .. py:method:: __post_init__()


   .. py:property:: variables
      :type: list[str]



   .. py:method:: ignore(variables: list[str])


   .. py:method:: __call__(array: numpy.ndarray) -> CutsResult


   .. py:method:: __add__(other: Cuts)


   .. py:method:: __len__() -> int


   .. py:method:: __iter__() -> collections.abc.Iterator


   .. py:method:: __getitem__(variable)


   .. py:method:: __repr__() -> str


.. py:data:: Flavours

.. py:class:: Label

   .. py:attribute:: name
      :type:  str


   .. py:attribute:: label
      :type:  str


   .. py:attribute:: cuts
      :type:  ftag.cuts.Cuts


   .. py:attribute:: colour
      :type:  str


   .. py:attribute:: category
      :type:  str


   .. py:attribute:: _px
      :type:  str | None
      :value: None



   .. py:property:: px
      :type: str



   .. py:property:: eff_str
      :type: str



   .. py:property:: rej_str
      :type: str



   .. py:property:: frac_str
      :type: str



   .. py:method:: __str__() -> str


   .. py:method:: __lt__(other) -> bool


.. py:class:: LabelContainer

   .. py:attribute:: labels
      :type:  dict[str, Label]


   .. py:method:: __iter__() -> collections.abc.Iterator


   .. py:method:: __getitem__(key) -> Label


   .. py:method:: __len__() -> int


   .. py:method:: __getattr__(name) -> Label


   .. py:method:: __contains__(label: str | Label) -> bool


   .. py:method:: __eq__(other) -> bool


   .. py:method:: __repr__() -> str


   .. py:property:: categories
      :type: list[str]



   .. py:method:: by_category(category: str) -> LabelContainer


   .. py:method:: from_cuts(cuts: list | ftag.cuts.Cuts) -> Label


   .. py:method:: from_yaml(yaml_path: pathlib.Path | None = None) -> LabelContainer
      :classmethod:



   .. py:method:: from_list(labels: list[Label]) -> LabelContainer
      :classmethod:



   .. py:method:: backgrounds(signal: Label, only_signals: bool = True) -> LabelContainer


.. py:function:: get_mock_file(num_jets=1000, fname: str | None = None, tracks_name: str = 'tracks', num_tracks: int = 40) -> tuple[str, h5py.File]

.. py:class:: Sample

   .. py:attribute:: pattern
      :type:  pathlib.Path | str | tuple[pathlib.Path | str, Ellipsis]


   .. py:attribute:: ntuple_dir
      :type:  pathlib.Path | str | None
      :value: None



   .. py:attribute:: name
      :type:  str | None
      :value: None



   .. py:attribute:: weights
      :type:  list[float] | None
      :value: None



   .. py:method:: __post_init__() -> None


   .. py:property:: path
      :type: tuple[pathlib.Path, Ellipsis]



   .. py:property:: files
      :type: list[str]



   .. py:property:: num_files
      :type: int



   .. py:property:: dsid
      :type: list[str]



   .. py:property:: sample_id
      :type: list[str]



   .. py:property:: tags
      :type: list[str]



   .. py:property:: ptag
      :type: list[str]



   .. py:property:: rtag
      :type: list[str]



   .. py:property:: dumper_tag
      :type: list[str]



   .. py:method:: virtual_file(**kwargs) -> list[pathlib.Path | str]


   .. py:method:: __str__()


   .. py:method:: __lt__(other)


   .. py:method:: __eq__(other)


.. py:class:: Transform

   .. py:attribute:: variable_map
      :type:  dict[str, dict[str, str]] | None
      :value: None



   .. py:attribute:: ints_map
      :type:  dict[str, dict[str, dict[int, int]]] | None
      :value: None



   .. py:attribute:: floats_map
      :type:  dict[str, dict[str, str | Callable]] | None
      :value: None



   .. py:method:: __post_init__()


   .. py:method:: __call__(batch: Batch) -> Batch


   .. py:method:: map_variables(batch: Batch) -> Batch

      Rename variables in a batch of data.

      :param batch: Dict of structured numpy arrays.
      :type batch: Batch

      :returns: Dict of structured numpy arrays with renamed variables.
      :rtype: Batch



   .. py:method:: map_ints(batch: Batch) -> Batch

      Map integer values to new values.

      :param batch: Dict of structured numpy arrays.
      :type batch: Batch

      :returns: Dict of structured numpy arrays with mapped integer values.
      :rtype: Batch



   .. py:method:: map_floats(batch: Batch) -> Batch

      Transform float values.

      :param batch: Dict of structured numpy arrays.
      :type batch: Batch

      :returns: Dict of structured numpy arrays with transformed float values.
      :rtype: Batch



   .. py:method:: map_dtype(name: str, dtype: numpy.dtype) -> numpy.dtype


   .. py:method:: map_variable_names(name: str, variables: list[str], inverse=False) -> list[str]


.. py:function:: get_working_points(args: argparse.Namespace) -> dict | None

   Calculate the working points.

   :param args: Input arguments from the argparser
   :type args: argparse.Namespace

   :returns: Dict with the working points. If args.outfile is given, the function returns None and
             stored the resulting dict in a yaml file in args.outfile.
   :rtype: dict | None


