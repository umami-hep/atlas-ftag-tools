ftag
====

.. py:module:: ftag

.. autoapi-nested-parse::

   atlas-ftag-tools - Common tools for ATLAS flavour tagging software.



Submodules
----------

.. toctree::
   :maxdepth: 1

   /autoapi/ftag/cli_utils/index
   /autoapi/ftag/cuts/index
   /autoapi/ftag/find_metadata/index
   /autoapi/ftag/fraction_optimization/index
   /autoapi/ftag/git_check/index
   /autoapi/ftag/hdf5/index
   /autoapi/ftag/labeller/index
   /autoapi/ftag/labels/index
   /autoapi/ftag/mock/index
   /autoapi/ftag/region/index
   /autoapi/ftag/sample/index
   /autoapi/ftag/track_selector/index
   /autoapi/ftag/transform/index
   /autoapi/ftag/utils/index
   /autoapi/ftag/vds/index
   /autoapi/ftag/working_points/index


Attributes
----------

.. autoapisummary::

   ftag.__version__


Exceptions
----------

.. autoapisummary::

   ftag.GitError


Classes
-------

.. autoapisummary::

   ftag.Cuts
   ftag.Labeller
   ftag.Label
   ftag.LabelContainer
   ftag.Sample
   ftag.Transform


Functions
---------

.. autoapisummary::

   ftag.check_for_fork
   ftag.check_for_uncommitted_changes
   ftag.create_and_push_tag
   ftag.get_git_hash
   ftag.is_git_repo
   ftag.get_mock_file
   ftag.get_working_points


Package Contents
----------------

.. py:data:: __version__
   :value: 'v0.2.15'


.. py:class:: Cuts

   Cuts dataclass to store multiple Cut instances and apply them.

   .. attribute:: cuts

      Tuple with the Cut instances

      :type: tuple[Cut, ...]


   .. py:attribute:: cuts
      :type:  tuple[Cut, Ellipsis]


   .. py:method:: from_list(cuts: list) -> Cuts
      :classmethod:



   .. py:method:: empty() -> Cuts
      :classmethod:



   .. py:method:: __post_init__()


   .. py:property:: variables
      :type: list[str]



   .. py:method:: ignore(variables: list[str])


   .. py:method:: __call__(array: numpy.ndarray) -> CutsResult


   .. py:method:: __add__(other: Cuts)


   .. py:method:: __len__() -> int


   .. py:method:: __iter__() -> collections.abc.Iterator


   .. py:method:: __getitem__(variable)


   .. py:method:: __repr__() -> str


.. py:exception:: GitError

   Bases: :py:obj:`Exception`


   Raised when a Git-related precondition is not satisfied.

   Initialize self.  See help(type(self)) for accurate signature.


.. py:function:: check_for_fork(path: str | os.PathLike[str], upstream: str) -> None

   Ensure the local clone's ``origin`` remote is a fork of ``upstream``.

   :param path: Filesystem path to the repository root or any directory within it.
   :type path: str | PathLike[str]
   :param upstream: Expected upstream repository URL substring (e.g. ``'github.com/org/repo'``).
   :type upstream: str

   :raises GitError: If the repository is present but its ``origin`` URL does not contain ``upstream``.

   .. rubric:: Notes

   If ``path`` is not a Git repository, the function returns silently.


.. py:function:: check_for_uncommitted_changes(path: str | os.PathLike[str]) -> None

   Raise if the repository at ``path`` has uncommitted changes.

   :param path: Filesystem path to the repository root or any directory within it.
   :type path: str | PathLike[str]

   :raises GitError: If ``path`` is a Git repository and there are uncommitted changes.

   .. rubric:: Notes

   - If ``path`` is **not** a Git repository, the function returns silently.
   - If the current process is running under ``pytest`` (detected via
     :data:`sys.modules`), the check is skipped and the function returns.


.. py:function:: create_and_push_tag(path: str | os.PathLike[str], upstream: str, tagname: str, msg: str) -> None

   Create an annotated Git tag and push it to ``origin``.

   :param path: Filesystem path to the repository root or any directory within it.
   :type path: str | PathLike[str]
   :param upstream: Expected upstream repository URL substring; passed to :func:`check_for_fork`.
   :type upstream: str
   :param tagname: Name of the tag to create.
   :type tagname: str
   :param msg: Annotation message for the tag (``git tag -m``).
   :type msg: str

   .. rubric:: Notes

   If ``path`` is not a Git repository, the function returns silently.


.. py:function:: get_git_hash(path: str | os.PathLike[str]) -> str | None

   Return the short commit hash for ``HEAD`` at ``path``, if available.

   :param path: Filesystem path to the repository root or any directory within it.
   :type path: str | PathLike[str]

   :returns: The short (``--short``) commit hash as a string, or ``None`` if ``path`` is
             not a Git repository.
   :rtype: str | None


.. py:function:: is_git_repo(path: str | os.PathLike[str]) -> bool

   Return whether ``path`` is inside a Git working tree.

   :param path: Filesystem path used as the current working directory for the Git command.
   :type path: str | PathLike[str]

   :returns: ``True`` if ``path`` is inside a Git working tree, ``False`` otherwise.
   :rtype: bool

   .. rubric:: Notes

   This function runs::

       git rev-parse --is-inside-work-tree HEAD

   Any non-zero exit status is treated as "not a Git repository". If Git is not
   available on the system, an :class:`OSError` may be raised by :mod:`subprocess`.


.. py:class:: Labeller

   Defines a labelling scheme.

   Classes are assigned integer labels in [0, ..., n] based on pre-defined selections.

   .. attribute:: labels

      The labels to be use.

      :type: LabelContainer | list[str | Label]

   .. attribute:: require_labels

      Whether to require that all objects are labelled.

      :type: bool


   .. py:attribute:: labels
      :type:  ftag.labels.LabelContainer | list[str | ftag.labels.Label]


   .. py:attribute:: require_labels
      :type:  bool
      :value: True



   .. py:method:: __post_init__() -> None


   .. py:property:: variables
      :type: list[str]


      Returns the variables used for labelling.

      :returns: The variables used for labelling.
      :rtype: list[str]


   .. py:method:: get_labels(array: numpy.ndarray) -> numpy.ndarray

      Returns the labels for the given array.

      :param array: The array to label.
      :type array: np.ndarray

      :returns: The labels for the given array.
      :rtype: np.ndarray

      :raises ValueError: If the `require_labels` attribute is set to `True` and some objects were not labelled.



   .. py:method:: add_labels(array: numpy.ndarray, label_name: str = 'labels') -> numpy.ndarray

      Adds the labels to the given array.

      :param array: The array to label.
      :type array: np.ndarray
      :param label_name: The name of the label column.
      :type label_name: str

      :returns: The array with the labels added.
      :rtype: np.ndarray

      :raises ValueError: If the `require_labels` attribute is set to `False`.



.. py:class:: Label

   Dataclass to hold info about one flavour/label.

   .. attribute:: name

      Name of the flavour/label

      :type: str

   .. attribute:: label

      Plot label for this flavour/label

      :type: str

   .. attribute:: cuts

      Cuts of this flavour/label

      :type: Cuts

   .. attribute:: colour

      Colour of this flavour/label

      :type: str

   .. attribute:: category

      Flavour category, to which this flavour/label belongs

      :type: str


   .. py:attribute:: name
      :type:  str


   .. py:attribute:: label
      :type:  str


   .. py:attribute:: cuts
      :type:  ftag.cuts.Cuts


   .. py:attribute:: colour
      :type:  str


   .. py:attribute:: category
      :type:  str


   .. py:attribute:: _px
      :type:  str | None
      :value: None



   .. py:property:: px
      :type: str



   .. py:property:: eff_str
      :type: str



   .. py:property:: rej_str
      :type: str



   .. py:property:: frac_str
      :type: str



   .. py:method:: __str__() -> str


   .. py:method:: __lt__(other) -> bool


.. py:class:: LabelContainer

   Label container that holds multiple labels.

   .. attribute:: labels

      Dict with the labels this container will hold

      :type: dict[str, Label]


   .. py:attribute:: labels
      :type:  dict[str, Label]


   .. py:method:: __iter__() -> collections.abc.Iterator


   .. py:method:: __getitem__(key) -> Label


   .. py:method:: __len__() -> int


   .. py:method:: __getattr__(name) -> Label


   .. py:method:: __contains__(label: str | Label) -> bool


   .. py:method:: __eq__(other) -> bool


   .. py:method:: __repr__() -> str


   .. py:property:: categories
      :type: list[str]



   .. py:method:: by_category(category: str) -> LabelContainer


   .. py:method:: from_cuts(cuts: list | ftag.cuts.Cuts) -> Label


   .. py:method:: from_yaml(yaml_path: pathlib.Path | None = None, include_categories: collections.abc.Iterable[str] | None = None, exclude_categories: collections.abc.Iterable[str] | None = None) -> LabelContainer
      :classmethod:



   .. py:method:: from_list(labels: list[Label]) -> LabelContainer
      :classmethod:



   .. py:method:: backgrounds(signal: Label, only_signals: bool = True) -> LabelContainer


.. py:function:: get_mock_file(num_jets: int = 1000, fname: str | None = None, tracks_name: str = 'tracks', num_tracks: int = 40) -> tuple[str, h5py.File]

   Get a mock file for testing.

   :param num_jets: Number of jets in the file, by default 1000
   :type num_jets: int, optional
   :param fname: Name of the file, by default None
   :type fname: str | None, optional
   :param tracks_name: Name of the tracks dataset, by default "tracks"
   :type tracks_name: str, optional
   :param num_tracks: Number of tracks per jet, by default 40
   :type num_tracks: int, optional

   :returns: Tuple with the path and the h5 file
   :rtype: tuple[str, h5py.File]


.. py:class:: Sample

   Dataclass which holds info about a specific sample.

   .. attribute:: pattern

      Filepattern for the h5 files

      :type: Path | str | tuple[Path | str, ...]

   .. attribute:: ntuple_dir

      Ntuple directory where the h5 files are stored, by default None

      :type: Path | str | None, optional

   .. attribute:: name

      Name of the sample, for internal identification, by default None

      :type: str | None, optional

   .. attribute:: weights

      List of weights for this sample, by default None

      :type: list[float] | None, optional

   .. attribute:: skip_checks

      Decide, if certain checks are skipped, by default False

      :type: bool, optional


   .. py:attribute:: pattern
      :type:  pathlib.Path | str | tuple[pathlib.Path | str, Ellipsis]


   .. py:attribute:: ntuple_dir
      :type:  pathlib.Path | str | None
      :value: None



   .. py:attribute:: name
      :type:  str | None
      :value: None



   .. py:attribute:: weights
      :type:  list[float] | None
      :value: None



   .. py:attribute:: skip_checks
      :type:  bool
      :value: False



   .. py:method:: __post_init__() -> None


   .. py:property:: path
      :type: tuple[pathlib.Path, Ellipsis]



   .. py:property:: files
      :type: list[str]



   .. py:property:: num_files
      :type: int



   .. py:property:: dsid
      :type: list[str]



   .. py:property:: sample_id
      :type: list[str]



   .. py:property:: tags
      :type: list[str]



   .. py:property:: ptag
      :type: list[str]



   .. py:property:: rtag
      :type: list[str]



   .. py:property:: dumper_tag
      :type: list[str]



   .. py:method:: virtual_file(**kwargs) -> list[pathlib.Path | str]


   .. py:method:: __str__()


   .. py:method:: __lt__(other)


   .. py:method:: __eq__(other)


.. py:class:: Transform

   Transform class to transform variables.

   .. attribute:: variable_map

      Map with the old and new variables

      :type: dict[str, dict[str, str]] | None, optional

   .. attribute:: ints_map

      Map with the old and new integer values

      :type: dict[str, dict[str, dict[int, int]]] | None, optional

   .. attribute:: floats_map

      Map with the old and new float values

      :type: dict[str, dict[str, str | Callable]] | None, optional


   .. py:attribute:: variable_map
      :type:  dict[str, dict[str, str]] | None
      :value: None



   .. py:attribute:: ints_map
      :type:  dict[str, dict[str, dict[int, int]]] | None
      :value: None



   .. py:attribute:: floats_map
      :type:  dict[str, dict[str, str | collections.abc.Callable]] | None
      :value: None



   .. py:method:: __post_init__()


   .. py:method:: __call__(batch: Batch) -> Batch


   .. py:method:: map_variables(batch: Batch) -> Batch

      Rename variables in a batch of data.

      :param batch: Dict of structured numpy arrays.
      :type batch: Batch

      :returns: Dict of structured numpy arrays with renamed variables.
      :rtype: Batch



   .. py:method:: map_ints(batch: Batch) -> Batch

      Map integer values to new values.

      :param batch: Dict of structured numpy arrays.
      :type batch: Batch

      :returns: Dict of structured numpy arrays with mapped integer values.
      :rtype: Batch



   .. py:method:: map_floats(batch: Batch) -> Batch

      Transform float values.

      :param batch: Dict of structured numpy arrays.
      :type batch: Batch

      :returns: Dict of structured numpy arrays with transformed float values.
      :rtype: Batch



   .. py:method:: map_dtype(name: str, dtype: numpy.dtype) -> numpy.dtype


   .. py:method:: map_variable_names(name: str, variables: list[str], inverse=False) -> list[str]


.. py:function:: get_working_points(args: argparse.Namespace) -> dict | None

   Calculate the working points.

   :param args: Input arguments from the argparser
   :type args: argparse.Namespace

   :returns: Dict with the working points. If args.outfile is given, the function returns None and
             stored the resulting dict in a yaml file in args.outfile.
   :rtype: dict | None


